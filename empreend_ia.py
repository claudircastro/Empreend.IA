# -*- coding: utf-8 -*-
"""CÃ³pia de CÃ³pia de EpreenderIA 1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/11ZJnPX5V31j87TrzcBaQC79rlmLmPVmx
"""



# Instalar as bibliotecas necessÃ¡rias (rode no colab)
!pip install -U google-genai -q
!pip install -q google-adk

# ImportaÃ§Ãµes e configuraÃ§Ã£o
import os
from google.colab import userdata
import google.generativeai as genai  # Biblioteca oficial para Gemini (genai)

# ConfiguraÃ§Ã£o dos tools disponÃ­veis no modelo Gemini (sÃ³ o nome da ferramenta)
TOOLS = ["google_search"]

# Quebrando o Texto por Linhas
from IPython.display import HTML, Markdown
import textwrap


# Configurar chave da API do Gemini
os.environ["GOOGLE_API_KEY"] = userdata.get("GOOGLE_API_KEY")
genai.configure(api_key=os.environ["GOOGLE_API_KEY"])


# ImportaÃ§Ãµes do ADK
from google.adk.agents import Agent
from google.adk.runners import Runner
from google.adk.sessions import InMemorySessionService
from google.genai import types # This import is for types, not the main model
from datetime import date
import ast  # SeguranÃ§a ao avaliar dicionÃ¡rios do agente

#funÃ§Ã£o auxiliar chamar agentes
def call_agent(agent: Agent, message_text: str) -> str:
    session_service = InMemorySessionService()
    session = session_service.create_session(app_name=agent.name, user_id="user1", session_id="session1")
    runner = Runner(agent=agent, app_name=agent.name, session_service=session_service)
    content = types.Content(role="user", parts=[types.Part(text=message_text)])
    final_response = ""
    for event in runner.run(user_id="user1", session_id="session1", new_message=content):
        if event.is_final_response():
            for part in event.content.parts:
                if part.text:
                    final_response += part.text + "\n"
    return final_response

# MEMÃ“RIA GLOBAL (pode ser exportada para JSON, Planilha, etc.)
perfil_usuario = {}

# FunÃ§Ã£o auxiliar para exibir texto formatado em Markdown no Colab
def to_markdown(text):
  text = text.replace('â€¢', '  *')
  return Markdown(textwrap.indent(text, '> ', predicate=lambda _: True))

# DICIONÃRIO
# melhorar: criar em um arquivo externo .py
metodos_produtividade = {
    "GTD": {
        "organizacao": ["metas", "livre"],
        "descricao": (
            "O mÃ©todo Getting Things Done (GTD) foca em capturar todas as tarefas e compromissos "
            "fora da mente, organizÃ¡-los em listas especÃ­ficas e revisÃ¡-los regularmente para aumentar a produtividade."
        ),
        "exemplo_uso": (
            "Liste todas as suas tarefas, categorize-as por contexto (ex: 'telefonemas', 'compras'), "
            "e revise semanalmente para priorizar o que deve ser feito."
        ),
        "ferramentas": ["Todoist", "Evernote", "Notion"]
    },
    "Ivy Lee": {
        "organizacao": ["metas", "time_blocking"],
        "descricao": (
            "MÃ©todo simples que prioriza atÃ© 6 tarefas importantes para o dia seguinte, "
            "executando-as em ordem, ajudando a focar no essencial."
        ),
        "exemplo_uso": (
            "No final do dia, escreva as 6 tarefas mais importantes para amanhÃ£, "
            "comece pela primeira e sÃ³ passe para a prÃ³xima quando terminar."
        ),
        "ferramentas": ["Bloco de notas", "Todoist"]
    },
    "Pomodoro": {
        "organizacao": ["time_blocking", "livre"],
        "descricao": (
            "Trabalhar em blocos de tempo focado de 25 minutos, seguidos por pausas curtas, "
            "aumentando a concentraÃ§Ã£o e prevenindo fadiga."
        ),
        "exemplo_uso": (
            "Configure um timer para 25 minutos e trabalhe sem distraÃ§Ãµes. "
            "ApÃ³s o alarme, faÃ§a uma pausa de 5 minutos. Repita 4 vezes e faÃ§a uma pausa maior."
        ),
        "ferramentas": ["Pomodone", "TomatoTimer", "Forest"]
    },
    "Kanban": {
        "organizacao": ["to_do", "livre"],
        "descricao": (
            "Sistema visual que organiza tarefas em colunas como 'A fazer', 'Fazendo' e 'Feito', "
            "facilitando o acompanhamento do fluxo de trabalho."
        ),
        "exemplo_uso": (
            "Crie cartÃµes para cada tarefa e mova-os entre as colunas conforme o progresso, "
            "visualizando claramente o status das atividades."
        ),
        "ferramentas": ["Trello", "Asana", "ClickUp"]
    }
}

"""# FunÃ§Ã£o de busca usando Gemini com Google Search tool
def buscar_com_google_gemini(query: str):
    # Cria o modelo Gemini com a ferramenta google_search ativada
    model = genai.GenerativeModel(
        model_name="gemini-1.5-pro-latest",
        tools=[{"name": "google_search"}]  # Apenas 'name' da ferramenta, sem 'type'
    )
    # Gera o conteÃºdo usando o prompt e ativando a funÃ§Ã£o de busca
    response = model.generate_content(query)
    return response.text"""

def buscar_com_google_gemini(query: str):
  model = genai.GenerativeModel(
      model_name="gemini-1.5-pro-latest",
      tools=[{"name": "google_search"}]
  )

  # Limita tamanho do prompt a 500 caracteres (ajustÃ¡vel)
  query_limpa = query.strip()[:500]

  try:
      response = model.generate_content(query_limpa)
      return response.text
  except Exception as e:
      return f"Erro ao buscar: {e}"

# FUNÃ‡ÃƒO ENTREVISTA
def entrevista_interativa():
    respostas = {}

    perguntas = {
        "segmento": "1. Qual Ã© o segmento principal da sua empresa? (Ex: AlimentaÃ§Ã£o, Moda, Tecnologia, ServiÃ§os, etc.)",
        "tipo_negocio": "2. Seu tipo de negÃ³cio se encaixa mais como: e-commerce, venda de produtos fÃ­sicos, prestaÃ§Ã£o de serviÃ§os, consultoria, ou outro?",
        "objetivo": "3. Qual Ã© o seu principal objetivo para o seu negÃ³cio neste momento? (Ex: Aumentar vendas, organizar minhas finanÃ§as, melhorar meu marketing, otimizar meu tempo, etc.)",
        "organizacao": "4. Pensando em como vocÃª geralmente lida com suas tarefas e seu tempo, qual das opÃ§Ãµes abaixo descreve melhor seu estilo de produtividade?\n\
a) Focado em metas\nb) Organizado por tempo\nc) FlexÃ­vel e adaptÃ¡vel\nd) Orientado por listas"
    }
    for chave, pergunta in perguntas.items():
        resposta = input(pergunta + "\n> ")
        respostas[chave] = resposta

    return respostas

# AGENTE 1 - PERFILADOR
# melhorar: coletar informaÃ§Ãµes durante qualquer interaÃ§Ã£o (de forma dinamica) para adicionar novas variaveis dentro de perfil
def agente_classificador_de_perfil(respostas):
    """
    Interpreta e classifica as respostas da entrevista_interativa() com base em perfis padronizados.
    Retorna um dicionÃ¡rio com labels estruturados.
    """
    perfil = {}

    # Segmento (mantÃ©m texto original do usuÃ¡rio)
    segmento = respostas.get("segmento", "").strip()
    perfil["segmento"] = segmento

    #Tipo de negÃ³cio
    tipo = respostas.get("tipo_negocio", "").lower()
    # Categorias com palavras relacionadas
    palavras_produto = ["produto", "produtos", "fabricaÃ§Ã£o", "fabricacao", "industrial"]
    palavras_servico = ["serviÃ§o", "servico", "prestaÃ§Ã£o", "consultoria", "atendimento", "freelancer"]
    palavras_online = ["e-commerce", "loja virtual", "digital", "online", "marketplace"]
    palavras_fisico = ["fÃ­sico", "fisico", "loja fÃ­sica", "presencial", "ponto de venda"]

    # Verifica a qual categoria pertence
    if any(p in tipo for p in palavras_produto):
        perfil["tipo_negocio"] = "produto"
    elif any(p in tipo for p in palavras_servico):
        perfil["tipo_negocio"] = "servico"
    elif any(p in tipo for p in palavras_online):
        perfil["tipo_negocio"] = "online"
    elif any(p in tipo for p in palavras_fisico):
        perfil["tipo_negocio"] = "fisico"
    else:
        perfil["tipo_negocio"] = "hibrido"

    # Objetivo
    objetivo = respostas.get("objetivo", "").lower()
    if "vender" in objetivo:
        perfil["objetivo"] = "vender_mais"
    elif "organizar" in objetivo or "rotina" in objetivo:
        perfil["objetivo"] = "organizar_rotina"
    elif "tempo" in objetivo or "automatizar" in objetivo:
        perfil["objetivo"] = "ganhar_tempo"
    else:
        perfil["objetivo"] = "neutro"

    # Estilo de organizaÃ§Ã£o
    org = respostas.get("organizacao", "").lower().strip()

    if org.startswith("b"):
        perfil["organizacao"] = "time_blocking"
    elif org.startswith("a"):
        perfil["organizacao"] = "metas"
    elif org.startswith("d"):
        perfil["organizacao"] = "to_do"
    elif org.startswith("c"):
        perfil["organizacao"] = "livre"
    else:
        perfil["organizacao"] = "indefinido"

    def adicionar_metodo(perfil, metodos_produtividade):
      # Seleciona os mÃ©todos baseado na organizaÃ§Ã£o
      organizacao = perfil.get("organizacao", "")
      metodos_para_organizacao = [
          metodo for metodo, dados in metodos_produtividade.items()
          if organizacao in dados["perfil_indicado"]
      ]
      # Atualiza o perfil com os mÃ©todos encontrados ou usa ["GTD"] como padrÃ£o
      perfil["metodos_produtividade"] = metodos_para_organizacao or ["GTD"]

    return perfil
    print (to_markdown(perfil))

# AGENTE 2 APRESENTADOR
def agente_apresentador_de_perfil(perfil_usuario):
    agente = Agent(
        name="agente_apresentador",
        model="gemini-2.0-flash",
        instruction="""
        VocÃª Ã© um assistente pessoal empÃ¡tico e inteligente.
        Sua missÃ£o Ã© ler o perfil de um empreendedor e:

        1. Fazer um comentÃ¡rio breve, simpÃ¡tico e acolhedor sobre o estilo da pessoa.
        2. Mostrar que vocÃª compreende o contexto e o ramo de atuaÃ§Ã£o dela.
        3. Reafirmar que todas as suas respostas a partir de agora serÃ£o adaptadas a esse perfil.
        4. Perguntar, com naturalidade e leveza, o que ela precisa resolver HOJE.

        Use linguagem clara, respeitosa e personalizada.
        Adapte o tom da resposta conforme o estilo de foco ou organizaÃ§Ã£o do usuÃ¡rio.
        Pode usar emojis se o perfil sugerir algo mais informal.
        Evite parecer robÃ³tico. Soe como alguÃ©m que entende gente de verdade.
        """,
        description="Apresentador de perfil e primeiro contato amigÃ¡vel com o usuÃ¡rio"
    )

    prompt = f"Perfil do usuÃ¡rio:\n{perfil_usuario}"
    print("ðŸŒŸ Apresentando o perfil e iniciando o atendimento personalizado...\n")
    resposta = call_agent(agente, prompt)
    print(resposta)
    return to_markdown(resposta)

# AGENTE 3 EXECUTOR
def agente_executor_personalizado(pedido_usuario: str, perfil: dict) -> str:
    agente = Agent(
        name="agente_executor_personalizado",
        model="gemini-2.0-flash",
        # melhorar: data dinamica
        instruction=f""" VocÃª Ã© um assistente prÃ¡tico e visionÃ¡rio, feito para apoiar pequenos empreendedores brasileiros com base nas tendÃªncias mais recentes (atÃ© maio de 2025)
         e orientaÃ§Ãµes do Sebrae. Use um tom encorajador e, quando apropriado, um toque de humor leve para motivar.

        â†’ Baseie suas respostas no perfil do usuÃ¡rio:
          - OrganizaÃ§Ã£o: {perfil.get('organizacao')}
          - Tipo de negÃ³cio: {perfil.get('tipo_negocio')}
          - Segmento: {perfil.get('segmento')}
          - Objetivo principal: {perfil.get('objetivo')}
          - Metodos de produtividade recomendados: {perfil.get('metodos_produtividade')}

        â†’ Adapte sua comunicaÃ§Ã£o com base nesses perfis. Use uma tabela interna para modular tom, formato e sugestÃµes.

        â†’ Sempre que o tema permitir, pergunte sutilmente sobre aÃ§Ãµes sustentÃ¡veis no negÃ³cio. Enfatize que empresas comprometidas com o planeta tendem a liderar o futuro do mercado.

        â†’ Seja sempre:
          - Claro e conciso (respostas curtas, sem floreios)
          - Personalizado (nada genÃ©rico)
          - Focado em aÃ§Ã£o prÃ¡tica, metas e acompanhamento
          - Atualizado com dados do Sebrae, tendÃªncias digitais e comportamento do consumidor

        â†’ Incentive:
          - ParticipaÃ§Ã£o em conselhos e redes de apoio locais
          - Cursos e capacitaÃ§Ãµes
          - InovaÃ§Ã£o constante
          - O associativismo como caminho de crescimento

       â†’ Se o pedido estiver incompleto ou muito geral, utilize seu conhecimento sobre o perfil e incentive o usuÃ¡rio a dar mais contexto com leveza â€” mas continue ajudando com o que for possÃ­vel.
      â†’ Se o metodo de produtividade do usuÃ¡rio for conhecido, vocÃª pode sugerir um mÃ©todo que combine com ele e com a solicitaÃ§Ã£o que ele te fez. Use linguagem leve, como: Nesse caso, talvez o mÃ©todo X funcione bem pra vocÃª.
      Pedido do usuÃ¡rio: "{pedido_usuario}"
        """,
        description="Executor Personalizado: adapta respostas e sugestÃµes ao perfil do empreendedor"
    )

    resposta = call_agent(agente, pedido_usuario)
    return to_markdown(resposta)

# Bloco inicial: apresentaÃ§Ã£o e decisÃ£o
ola = f"""
      ðŸ‘‹ OlÃ¡! Sou o Empreend.AI, seu novo sÃ³cio digital! Para te ajudar de forma mais personalizada,
      quero te fazer 4 perguntas essenciais sobre sua empresa e seu estilo de trabalho. Podemos comeÃ§ar?
      Ou prefere ir direto ao ponto e me dizer em que posso te ajudar HOJE?

      """
display(to_markdown(ola))

resposta_inicial = input("âœï¸ Digite 'comeÃ§ar' ou 'direto':\n> ").lower()

if resposta_inicial == "direto":
    perfil_usuario = {"modo_direto": True}
    print("ðŸ‘ Perfeito! Pode me dizer com o que vocÃª precisa de ajuda agora.")
else:
    respostas_usuario = entrevista_interativa()
    perfil_usuario = agente_classificador_de_perfil(respostas_usuario)
    agente_apresentador_de_perfil(perfil_usuario)

# Loop contÃ­nuo da conversa
print("\nðŸš€ Agora vocÃª pode fazer seus pedidos. Digite 'sair' para encerrar.\n")
comandos_sair = {"sair", "exit", "quit", "parar", "encerrar", "fim", "tchau"}

while True:
    pedido = input("> ").strip()
    if pedido.lower() in comandos_sair:
        print("AtÃ© logo! Foi um prazer ajudar vocÃª. ðŸŒŸ")
        break

    # Dispara busca se a frase for maior que 4 palavras (para evitar buscas inÃºteis)
    if len(pedido.split()) > 4:
        busca = buscar_com_google_gemini(pedido)
        prompt_completo = f"{pedido}\n\nResultados da busca atual:\n{busca}"
    else:
        prompt_completo = pedido

    # Aqui vocÃª pode chamar sua funÃ§Ã£o/agent personalizada que responde baseado no prompt completo
    # Exemplo fictÃ­cio, substitua pela sua implementaÃ§Ã£o:
    resposta = agente_executor_personalizado(prompt_completo, perfil_usuario)

    display(resposta)

"""while True:
    pedido = input("> ").strip()
    if pedido.lower() in comandos_sair:
        print("AtÃ© logo! Foi um prazer ajudar vocÃª. ðŸŒŸ")
        break

    # Busca SEMPRE que o pedido tiver conteÃºdo relevante
    if len(pedido.split()) > 4:  # Evita busca para mensagens muito curtas
        busca = buscar_com_google_gemini(pedido)
        prompt_completo = f"{pedido}\n\nResultados da busca atual:\n{busca}"
    else:
        prompt_completo = pedido

    resposta = agente_executor_personalizado(prompt_completo, perfil_usuario)
    display(resposta)"""

